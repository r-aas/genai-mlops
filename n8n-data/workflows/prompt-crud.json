{
  "id": "prompt-crud-v1",
  "name": "Prompt Registry CRUD",
  "active": true,
  "nodes": [
    {
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "position": [
        240,
        340
      ],
      "parameters": {
        "path": "prompts",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "typeVersion": 2,
      "webhookId": "prompt-crud-webhook-id"
    },
    {
      "id": "crud-handler",
      "name": "CRUD Handler",
      "type": "n8n-nodes-base.code",
      "position": [
        480,
        340
      ],
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const axios = require('axios');\nconst M = 'http://mlflow:5050/api/2.0/mlflow';\nconst body = $input.item.json.body;\nconst action = body.action;\n\ntry {\n\nif (!action) throw new Error('action required: create, get, list, update, delete');\n\nasync function post(path, data) {\n  var r = await axios.post(M + path, data);\n  return r.data;\n}\n\nasync function apiGet(path) {\n  var r = await axios.get(M + path);\n  return r.data;\n}\n\nasync function apiDel(path, data) {\n  var r = await axios({method: 'DELETE', url: M + path, data: data});\n  return r.data;\n}\n\nif (action === 'create') {\n  var name = body.name, tmpl = body.template;\n  if (!name || !tmpl) throw new Error('name and template required');\n  await post('/registered-models/create', {name: name});\n  await post('/registered-models/set-tag', {name: name, key: 'mlflow.prompt.is_prompt', value: 'true'});\n  var tags = body.tags || {};\n  for (var k of Object.keys(tags)) await post('/registered-models/set-tag', {name: name, key: k, value: String(tags[k])});\n  var mv = await post('/model-versions/create', {name: name, source: 'prompts:/' + name + '/1'});\n  var ver = mv.model_version.version;\n  await post('/model-versions/set-tag', {name: name, version: ver, key: 'mlflow.prompt.text', value: tmpl});\n  if (body.commit_message) await post('/model-versions/set-tag', {name: name, version: ver, key: 'mlflow.prompt.commit_message', value: body.commit_message});\n  await post('/registered-models/alias', {name: name, alias: 'production', version: ver});\n  return {action: 'create', name: name, version: ver, status: 'created'};\n}\n\nif (action === 'get') {\n  var name = body.name;\n  if (!name) throw new Error('name required');\n  var alias = body.alias || 'production';\n  var rm = await apiGet('/registered-models/get?name=' + encodeURIComponent(name));\n  var modelObj = rm.registered_model;\n  var ae = (modelObj.aliases || []).find(function(a) { return a.alias === alias; });\n  if (!ae) throw new Error('Alias ' + alias + ' not found on ' + name);\n  // Fix: fetch version directly via model-versions/get\n  var mvResp = await apiGet('/model-versions/get?name=' + encodeURIComponent(name) + '&version=' + ae.version);\n  var mv = mvResp.model_version;\n  var vTags = mv.tags || [];\n  var pt = vTags.find(function(t) { return t.key === 'mlflow.prompt.text'; });\n  var tmpl = pt ? pt.value : '';\n  var vars = [];\n  var matches = tmpl.match(/\\{\\{\\s*\\w+\\s*\\}\\}/g);\n  if (matches) vars = matches.map(function(x) { return x.replace(/[{}\\s]/g, ''); });\n  var ct = {};\n  vTags.filter(function(t) { return t.key.indexOf('mlflow.') !== 0 && t.key.indexOf('_mlflow') !== 0; }).forEach(function(t) { ct[t.key] = t.value; });\n  return {action: 'get', name: modelObj.name, version: mv.version, alias: alias, template: tmpl, variables: vars, tags: ct};\n}\n\nif (action === 'list') {\n  var f = \"tags.`mlflow.prompt.is_prompt`='true'\";\n  var result = await apiGet('/registered-models/search?filter=' + encodeURIComponent(f));\n  var prompts = (result.registered_models || []).map(function(rm) {\n    var aliases = {};\n    (rm.aliases || []).forEach(function(a) { aliases[a.alias] = a.version; });\n    var ct = {};\n    (rm.tags || []).filter(function(t) { return t.key.indexOf('mlflow.') !== 0 && t.key.indexOf('_mlflow') !== 0; }).forEach(function(t) { ct[t.key] = t.value; });\n    return {name: rm.name, aliases: aliases, tags: ct};\n  });\n  return {action: 'list', count: prompts.length, prompts: prompts};\n}\n\nif (action === 'update') {\n  var name = body.name, tmpl = body.template;\n  if (!name || !tmpl) throw new Error('name and template required');\n  var mv = await post('/model-versions/create', {name: name, source: 'prompts:/' + name});\n  var ver = mv.model_version.version;\n  await post('/model-versions/set-tag', {name: name, version: ver, key: 'mlflow.prompt.text', value: tmpl});\n  if (body.commit_message) await post('/model-versions/set-tag', {name: name, version: ver, key: 'mlflow.prompt.commit_message', value: body.commit_message});\n  var tags = body.tags || {};\n  for (var k of Object.keys(tags)) await post('/model-versions/set-tag', {name: name, version: ver, key: k, value: String(tags[k])});\n  var alias = body.alias || 'production';\n  await post('/registered-models/alias', {name: name, alias: alias, version: ver});\n  return {action: 'update', name: name, version: ver, alias: alias, status: 'updated'};\n}\n\nif (action === 'delete') {\n  var name = body.name;\n  if (!name) throw new Error('name required');\n  if (body.version) {\n    // Guard: don't delete the version currently aliased as production\n    var rm = await apiGet('/registered-models/get?name=' + encodeURIComponent(name));\n    var prodAlias = (rm.registered_model.aliases || []).find(function(a) { return a.alias === 'production'; });\n    if (prodAlias && prodAlias.version === String(body.version)) {\n      throw new Error('Cannot delete version ' + body.version + ' \u2014 it is the current production alias. Re-alias first.');\n    }\n    await apiDel('/model-versions/delete', {name: name, version: String(body.version)});\n    return {action: 'delete', name: name, version: body.version, status: 'version_deleted'};\n  }\n  await apiDel('/registered-models/delete', {name: name});\n  return {action: 'delete', name: name, status: 'deleted'};\n}\n\nthrow new Error('Unknown action: ' + action);\n\n} catch(e) {\n  var msg = e.message || String(e);\n  if (e.response && e.response.data) msg += ' | ' + JSON.stringify(e.response.data);\n  var status = 400;\n  if (e.response && e.response.status === 404) status = 404;\n  if (msg.indexOf('RESOURCE_DOES_NOT_EXIST') !== -1) status = 404;\n  return {error: true, message: msg, action: action || 'unknown', _status: status};\n}"
      },
      "typeVersion": 2
    },
    {
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "position": [
        720,
        340
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ Object.fromEntries(Object.entries($json).filter(([k]) => k !== '_status')) }}",
        "options": {
          "responseCode": "={{ $json._status || 200 }}"
        }
      },
      "typeVersion": 1.2
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "CRUD Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CRUD Handler": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
