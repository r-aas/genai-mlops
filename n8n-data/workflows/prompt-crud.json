{
  "id": "prompt-crud-v1",
  "name": "Prompt Registry CRUD",
  "active": true,
  "nodes": [
    {
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "position": [
        240,
        340
      ],
      "parameters": {
        "path": "prompts",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "typeVersion": 2,
      "webhookId": "prompt-crud-webhook-id"
    },
    {
      "id": "crud-handler",
      "name": "CRUD Handler",
      "type": "n8n-nodes-base.code",
      "position": [
        480,
        340
      ],
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const axios = require('axios');\nconst M = 'http://mlflow:5050/api/2.0/mlflow';\nconst body = $input.item.json.body;\nconst action = body.action;\n\ntry {\n\nif (!action) throw new Error('action required: create, get, list, update, delete');\n\nasync function post(path, data) {\n  var r = await axios.post(M + path, data);\n  return r.data;\n}\n\nasync function apiGet(path) {\n  var r = await axios.get(M + path);\n  return r.data;\n}\n\nasync function apiDel(path, data) {\n  var r = await axios({method: 'DELETE', url: M + path, data: data});\n  return r.data;\n}\n\nif (action === 'create') {\n  var name = body.name, tmpl = body.template;\n  if (!name || !tmpl) throw new Error('name and template required');\n  await post('/registered-models/create', {name: name});\n  await post('/registered-models/set-tag', {name: name, key: 'mlflow.prompt.is_prompt', value: 'true'});\n  var tags = body.tags || {};\n  for (var k of Object.keys(tags)) await post('/registered-models/set-tag', {name: name, key: k, value: String(tags[k])});\n  var mv = await post('/model-versions/create', {name: name, source: 'prompts:/' + name + '/1'});\n  var ver = mv.model_version.version;\n  await post('/model-versions/set-tag', {name: name, version: ver, key: 'mlflow.prompt.text', value: tmpl});\n  if (body.commit_message) await post('/model-versions/set-tag', {name: name, version: ver, key: 'mlflow.prompt.commit_message', value: body.commit_message});\n  await post('/registered-models/alias', {name: name, alias: 'production', version: ver});\n  return {action: 'create', name: name, version: ver, status: 'created'};\n}\n\nif (action === 'get') {\n  var name = body.name;\n  if (!name) throw new Error('name required');\n  var alias = body.alias || 'production';\n  var rm = await apiGet('/registered-models/get?name=' + encodeURIComponent(name));\n  var model = rm.registered_model;\n  var ae = (model.aliases || []).find(function(a) { return a.alias === alias; });\n  if (!ae) throw new Error('Alias ' + alias + ' not found on ' + name);\n  var mv = (model.latest_versions || []).find(function(v) { return v.version === ae.version; });\n  if (!mv) throw new Error('Version ' + ae.version + ' not found');\n  var vTags = mv.tags || [];\n  var pt = vTags.find(function(t) { return t.key === 'mlflow.prompt.text'; });\n  var tmpl = pt ? pt.value : '';\n  var vars = [];\n  var matches = tmpl.match(/\\{\\{\\s*\\w+\\s*\\}\\}/g);\n  if (matches) vars = matches.map(function(x) { return x.replace(/[{}\\s]/g, ''); });\n  var ct = {};\n  vTags.filter(function(t) { return t.key.indexOf('mlflow.') !== 0; }).forEach(function(t) { ct[t.key] = t.value; });\n  return {action: 'get', name: model.name, version: mv.version, alias: alias, template: tmpl, variables: vars, tags: ct};\n}\n\nif (action === 'list') {\n  var f = \"tags.`mlflow.prompt.is_prompt`='true'\";\n  var result = await apiGet('/registered-models/search?filter=' + encodeURIComponent(f));\n  var prompts = (result.registered_models || []).map(function(rm) {\n    var aliases = {};\n    (rm.aliases || []).forEach(function(a) { aliases[a.alias] = a.version; });\n    var ct = {};\n    (rm.tags || []).filter(function(t) { return t.key.indexOf('mlflow.') !== 0; }).forEach(function(t) { ct[t.key] = t.value; });\n    return {name: rm.name, versions: (rm.latest_versions || []).length, aliases: aliases, tags: ct};\n  });\n  return {action: 'list', count: prompts.length, prompts: prompts};\n}\n\nif (action === 'update') {\n  var name = body.name, tmpl = body.template;\n  if (!name || !tmpl) throw new Error('name and template required');\n  var rm = await apiGet('/registered-models/get?name=' + encodeURIComponent(name));\n  var vers = rm.registered_model.latest_versions || [];\n  var maxV = 0;\n  vers.forEach(function(v) { var n = parseInt(v.version); if (n > maxV) maxV = n; });\n  var mv = await post('/model-versions/create', {name: name, source: 'prompts:/' + name + '/' + (maxV + 1)});\n  var ver = mv.model_version.version;\n  await post('/model-versions/set-tag', {name: name, version: ver, key: 'mlflow.prompt.text', value: tmpl});\n  if (body.commit_message) await post('/model-versions/set-tag', {name: name, version: ver, key: 'mlflow.prompt.commit_message', value: body.commit_message});\n  var tags = body.tags || {};\n  for (var k of Object.keys(tags)) await post('/model-versions/set-tag', {name: name, version: ver, key: k, value: String(tags[k])});\n  var alias = body.alias || 'production';\n  await post('/registered-models/alias', {name: name, alias: alias, version: ver});\n  return {action: 'update', name: name, version: ver, alias: alias, status: 'updated'};\n}\n\nif (action === 'delete') {\n  var name = body.name;\n  if (!name) throw new Error('name required');\n  if (body.version) {\n    await apiDel('/model-versions/delete', {name: name, version: String(body.version)});\n    return {action: 'delete', name: name, version: body.version, status: 'version_deleted'};\n  }\n  await apiDel('/registered-models/delete', {name: name});\n  return {action: 'delete', name: name, status: 'deleted'};\n}\n\nthrow new Error('Unknown action: ' + action);\n\n} catch(e) {\n  var msg = e.message || String(e);\n  if (e.response && e.response.data) msg += ' | ' + JSON.stringify(e.response.data);\n  return {error: true, message: msg, action: action || 'unknown'};\n}"
      },
      "typeVersion": 2
    },
    {
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "position": [
        720,
        340
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "typeVersion": 1.1
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "CRUD Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CRUD Handler": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}